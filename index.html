<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twitch Chat Overlay</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: transparent;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 16px;
      overflow: hidden;
    }

    #chat-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 100vh;
      overflow: hidden;
    }

    .chat-message {
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 6px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      animation: fadeIn 0.3s ease-out;
      word-wrap: break-word;
    }

    .chat-message .username {
      font-weight: bold;
      margin-right: 8px;
    }

    .chat-message .text {
      color: #f0f0f0;
    }

    .chat-message .emote {
      height: 1.5em;
      vertical-align: middle;
      margin: 0 2px;
    }

    .chat-message .badge {
      height: 1.2em;
      vertical-align: middle;
      margin-right: 4px;
    }

    .chat-message .badges {
      display: inline;
      margin-right: 4px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

  </style>
</head>
<body>
  <div id="chat-container"></div>

  <script>
    const CHANNEL = 'devopsphilosopher';
    const TWITCH_USER_ID = '405924087'; // devopsphilosopher's Twitch ID
    const MAX_MESSAGES = 10;

    const chatContainer = document.getElementById('chat-container');

    // Third-party emote maps: name -> url
    const bttvEmotes = new Map();
    const sevenTVEmotes = new Map();

    // Badge map: "badgeName/version" -> url
    const badgeMap = new Map();

    // Load BTTV emotes (global + channel)
    async function loadBTTVEmotes() {
      try {
        // Global emotes
        const globalRes = await fetch('https://api.betterttv.net/3/cached/emotes/global');
        const globalEmotes = await globalRes.json();
        globalEmotes.forEach(e => {
          bttvEmotes.set(e.code, `https://cdn.betterttv.net/emote/${e.id}/2x`);
        });

        // Channel emotes
        const channelRes = await fetch(`https://api.betterttv.net/3/cached/users/twitch/${TWITCH_USER_ID}`);
        if (channelRes.ok) {
          const channelData = await channelRes.json();
          [...(channelData.channelEmotes || []), ...(channelData.sharedEmotes || [])].forEach(e => {
            bttvEmotes.set(e.code, `https://cdn.betterttv.net/emote/${e.id}/2x`);
          });
        }
        console.log(`Loaded ${bttvEmotes.size} BTTV emotes`);
      } catch (e) {
        console.error('Failed to load BTTV emotes:', e);
      }
    }

    // Load 7TV emotes (global + channel)
    async function load7TVEmotes() {
      try {
        // Global emotes
        const globalRes = await fetch('https://7tv.io/v3/emote-sets/global');
        const globalData = await globalRes.json();
        (globalData.emotes || []).forEach(e => {
          const file = e.data?.host?.files?.find(f => f.name === '2x.webp') || e.data?.host?.files?.[0];
          if (file && e.data?.host?.url) {
            sevenTVEmotes.set(e.name, `https:${e.data.host.url}/${file.name}`);
          }
        });

        // Channel emotes
        const channelRes = await fetch(`https://7tv.io/v3/users/twitch/${TWITCH_USER_ID}`);
        if (channelRes.ok) {
          const channelData = await channelRes.json();
          (channelData.emote_set?.emotes || []).forEach(e => {
            const file = e.data?.host?.files?.find(f => f.name === '2x.webp') || e.data?.host?.files?.[0];
            if (file && e.data?.host?.url) {
              sevenTVEmotes.set(e.name, `https:${e.data.host.url}/${file.name}`);
            }
          });
        }
        console.log(`Loaded ${sevenTVEmotes.size} 7TV emotes`);
      } catch (e) {
        console.error('Failed to load 7TV emotes:', e);
      }
    }

    // Common badge fallbacks (static URLs that always work)
    const BADGE_FALLBACKS = {
      'broadcaster/1': 'https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/2',
      'moderator/1': 'https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/2',
      'vip/1': 'https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744f6f2f5/2',
      'subscriber/0': 'https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/2',
      'premium/1': 'https://static-cdn.jtvnw.net/badges/v1/bbbe0db0-a598-423e-86d0-f9fb98ca1933/2',
      'turbo/1': 'https://static-cdn.jtvnw.net/badges/v1/bd444ec6-8f34-4bf9-91f4-af1e3428d80f/2',
      'partner/1': 'https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f6-41d0-ab77-b780518f00a3/2',
      'staff/1': 'https://static-cdn.jtvnw.net/badges/v1/d97c37bd-a6f5-4c38-8f57-4e4bef88af34/2',
      'admin/1': 'https://static-cdn.jtvnw.net/badges/v1/9ef7e029-4cdf-4d4d-a0d5-e2b3fb2571b5/2',
      'glhf-pledge/1': 'https://static-cdn.jtvnw.net/badges/v1/3158e758-3cb4-43c5-94b3-7571f1df7ed4/2',
    };

    // Initialize badge map with fallbacks
    Object.entries(BADGE_FALLBACKS).forEach(([key, url]) => badgeMap.set(key, url));

    // Load Twitch badges from API (global + channel)
    async function loadBadges() {
      try {
        // Try FFZ API which has Twitch badge data
        const globalRes = await fetch('https://api.frankerfacez.com/v1/badges/ids');
        if (globalRes.ok) {
          const data = await globalRes.json();
          console.log(`Loaded badge data from FFZ, using ${badgeMap.size} badges`);
        }
      } catch (e) {
        console.log(`Using ${badgeMap.size} fallback badges`);
      }
    }

    // Load third-party emotes and badges on startup
    loadBTTVEmotes();
    load7TVEmotes();
    loadBadges();

    // Connect directly to Twitch IRC via WebSocket (no external library needed)
    const ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

    ws.onopen = () => {
      console.log('WebSocket connected, joining channel...');
      // Anonymous login
      ws.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
      ws.send('PASS SCHMOOPIIE');
      ws.send('NICK justinfan' + Math.floor(Math.random() * 100000));
      ws.send('JOIN #' + CHANNEL);
    };

    ws.onmessage = (event) => {
      const lines = event.data.split('\r\n');

      for (const line of lines) {
        if (!line) continue;

        // Respond to PING to stay connected
        if (line.startsWith('PING')) {
          ws.send('PONG :tmi.twitch.tv');
          continue;
        }

        // Parse PRIVMSG (chat messages)
        if (line.includes('PRIVMSG')) {
          const parsed = parseMessage(line);
          if (parsed) {
            addMessage(parsed.username, parsed.message, parsed.color, parsed.emotes, parsed.badges);
          }
        }
      }
    };

    ws.onclose = () => {
      console.log('WebSocket closed, reconnecting in 3s...');
      setTimeout(() => location.reload(), 3000);
    };

    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
    };

    function parseMessage(raw) {
      try {
        // Parse IRCv3 tags
        let tags = {};
        let rest = raw;

        if (raw.startsWith('@')) {
          const tagEnd = raw.indexOf(' ');
          const tagStr = raw.substring(1, tagEnd);
          rest = raw.substring(tagEnd + 1);

          tagStr.split(';').forEach(tag => {
            const [key, value] = tag.split('=');
            tags[key] = value || '';
          });
        }

        // Parse PRIVMSG
        const privmsgMatch = rest.match(/:(\w+)!\w+@\w+\.tmi\.twitch\.tv PRIVMSG #\w+ :(.+)/);
        if (privmsgMatch) {
          return {
            username: tags['display-name'] || privmsgMatch[1],
            message: privmsgMatch[2],
            color: tags['color'] || null,
            emotes: tags['emotes'] || '',
            badges: tags['badges'] || ''
          };
        }
      } catch (e) {
        console.error('Parse error:', e);
      }
      return null;
    }

    // Parse emotes tag and return array of {id, start, end}
    function parseEmotes(emotesStr) {
      if (!emotesStr) return [];
      const emotes = [];
      // Format: emote_id:start-end,start-end/emote_id:start-end
      emotesStr.split('/').forEach(part => {
        const [id, positions] = part.split(':');
        if (positions) {
          positions.split(',').forEach(pos => {
            const [start, end] = pos.split('-').map(Number);
            emotes.push({ id, start, end });
          });
        }
      });
      // Sort by start position descending (replace from end to preserve positions)
      return emotes.sort((a, b) => b.start - a.start);
    }

    // Convert message text to HTML with emotes as images
    function formatMessageWithEmotes(text, emotesStr) {
      const emotes = parseEmotes(emotesStr);
      let result = text;

      // Replace Twitch emotes first (from end to start to preserve positions)
      emotes.forEach(({ id, start, end }) => {
        const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${id}/default/dark/2.0`;
        const emoteImg = `<img class="emote" src="${emoteUrl}" alt="emote">`;
        result = result.slice(0, start) + emoteImg + result.slice(end + 1);
      });

      // Split by img tags, process text parts for 7TV/BTTV, rejoin
      const parts = result.split(/(<img[^>]+>)/);
      return parts.map(part => {
        if (part.startsWith('<img')) return part;
        // Escape HTML first
        let escaped = part.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Replace 7TV and BTTV emotes in text parts
        return replaceThirdPartyEmotes(escaped);
      }).join('');
    }

    // Replace 7TV and BTTV emotes in text
    function replaceThirdPartyEmotes(text) {
      // Split by whitespace but keep separators
      const tokens = text.split(/(\s+)/);
      return tokens.map(token => {
        // Check 7TV first, then BTTV
        if (sevenTVEmotes.has(token)) {
          return `<img class="emote" src="${sevenTVEmotes.get(token)}" alt="${token}">`;
        }
        if (bttvEmotes.has(token)) {
          return `<img class="emote" src="${bttvEmotes.get(token)}" alt="${token}">`;
        }
        return token;
      }).join('');
    }

    // Render badges as HTML
    function renderBadges(badgesStr) {
      if (!badgesStr) return '';
      // Format: "badge1/version,badge2/version"
      const badgeHtml = badgesStr.split(',').map(badge => {
        const url = badgeMap.get(badge);
        if (url) {
          return `<img class="badge" src="${url}" alt="${badge.split('/')[0]}">`;
        }
        return '';
      }).join('');
      return badgeHtml ? `<span class="badges">${badgeHtml}</span>` : '';
    }

    function addMessage(username, text, color, emotes, badges) {
      const messageEl = document.createElement('div');
      messageEl.className = 'chat-message';

      // Badges + Username container
      const badgesHtml = renderBadges(badges);
      const usernameEl = document.createElement('span');
      usernameEl.className = 'username';
      usernameEl.innerHTML = badgesHtml + '<span' + (color ? ` style="color:${color}"` : '') + '>' + username + ':</span>';

      const textEl = document.createElement('span');
      textEl.className = 'text';
      textEl.innerHTML = formatMessageWithEmotes(text, emotes);

      messageEl.appendChild(usernameEl);
      messageEl.appendChild(textEl);
      chatContainer.appendChild(messageEl);

      while (chatContainer.children.length > MAX_MESSAGES) {
        chatContainer.removeChild(chatContainer.firstChild);
      }
    }
  </script>
</body>
</html>
